package capnweb

import (
	"context"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"reflect"
	"strings"
	"text/template"
)

// CodeGenerator generates type-safe stubs from interface definitions
type CodeGenerator struct {
	registry *InterfaceRegistry
	options  CodeGenOptions
}

// CodeGenOptions configures code generation behavior
type CodeGenOptions struct {
	// PackageName for generated code
	PackageName string

	// OutputFile path for generated code
	OutputFile string

	// GenerateComments includes documentation comments
	GenerateComments bool

	// GenerateValidation includes runtime validation
	GenerateValidation bool

	// UseGenerics enables Go 1.18+ generics
	UseGenerics bool

	// ImportPath for the capnweb package
	ImportPath string

	// ExtraImports for additional imports needed
	ExtraImports []string
}

// DefaultCodeGenOptions returns reasonable defaults
func DefaultCodeGenOptions() CodeGenOptions {
	return CodeGenOptions{
		PackageName:        "main",
		GenerateComments:   true,
		GenerateValidation: true,
		UseGenerics:        true,
		ImportPath:         "github.com/develerltd/capnweb",
	}
}

// NewCodeGenerator creates a new code generator
func NewCodeGenerator(registry *InterfaceRegistry, options CodeGenOptions) *CodeGenerator {
	if registry == nil {
		registry = DefaultRegistry
	}

	return &CodeGenerator{
		registry: registry,
		options:  options,
	}
}

// GenerateCode generates Go code for all registered interfaces
func (g *CodeGenerator) GenerateCode(writer io.Writer) error {
	// Collect all interfaces
	interfaces := make([]*RpcInterface, 0, len(g.registry.interfaces))
	for _, iface := range g.registry.interfaces {
		interfaces = append(interfaces, iface)
	}

	// Generate code using templates
	return g.generateFromTemplate(writer, interfaces)
}

// GenerateInterface generates code for a specific interface
func (g *CodeGenerator) GenerateInterface(writer io.Writer, interfaceName string) error {
	iface, exists := g.registry.GetInterface(interfaceName)
	if !exists {
		return fmt.Errorf("interface %s not found", interfaceName)
	}

	return g.generateFromTemplate(writer, []*RpcInterface{iface})
}

// generateFromTemplate uses Go templates to generate code
func (g *CodeGenerator) generateFromTemplate(writer io.Writer, interfaces []*RpcInterface) error {
	tmpl := template.New("stub").Funcs(template.FuncMap{
		"toLower":         strings.ToLower,
		"title":           strings.Title,
		"hasReturn":       func(m *RpcMethod) bool { return m.OutputType != nil },
		"returnType":      func(m *RpcMethod) string { return g.formatType(m.OutputType) },
		"promiseType":     func(m *RpcMethod) string { return g.formatPromiseType(m) },
		"formatParams":    func(m *RpcMethod) string { return g.formatParameters(m) },
		"formatArgs":      func(m *RpcMethod) string { return g.formatArguments(m) },
		"needsValidation": func(m *RpcMethod) bool { return g.options.GenerateValidation },
	})

	tmplContent := g.getTemplate()
	tmpl, err := tmpl.Parse(tmplContent)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		PackageName   string
		ImportPath    string
		ExtraImports  []string
		Interfaces    []*RpcInterface
		UseGenerics   bool
		WithComments  bool
		WithValidation bool
	}{
		PackageName:    g.options.PackageName,
		ImportPath:     g.options.ImportPath,
		ExtraImports:   g.options.ExtraImports,
		Interfaces:     interfaces,
		UseGenerics:    g.options.UseGenerics,
		WithComments:   g.options.GenerateComments,
		WithValidation: g.options.GenerateValidation,
	}

	return tmpl.Execute(writer, data)
}

// getTemplate returns the Go template for stub generation
func (g *CodeGenerator) getTemplate() string {
	return `// Code generated by capnweb-gen. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"

	"{{.ImportPath}}"
{{range .ExtraImports}}	"{{.}}"
{{end}})

{{range .Interfaces}}
{{if $.WithComments}}// {{.Name}}Stub provides RPC access to {{.Name}} service
{{end}}type {{.Name}}Stub struct {
	session  *capnweb.Session
	importID capnweb.ImportID
	stub     capnweb.Stub
}

{{if $.WithComments}}// New{{.Name}}Stub creates a new {{.Name}} RPC stub
{{end}}func New{{.Name}}Stub(session *capnweb.Session, importID capnweb.ImportID) (*{{.Name}}Stub, error) {
	stub, err := session.CreateImportStub(importID, false)
	if err != nil {
		return nil, fmt.Errorf("failed to create stub: %w", err)
	}

	return &{{.Name}}Stub{
		session:  session,
		importID: importID,
		stub:     stub,
	}, nil
}

{{range .Methods}}
{{if $.WithComments}}// {{.Name}} calls the remote {{.Name}} method{{if .Tags.Description}}
// {{.Tags.Description}}{{end}}{{if .Tags.Deprecated}}
// Deprecated: {{.Tags.Deprecated}}{{end}}
{{end}}func (s *{{$.Name}}Stub) {{.Name}}({{formatParams .}}) {{promiseType .}} {
{{if $.WithValidation}}	// Runtime validation
	args := []interface{}{ {{formatArgs .}} }
	if err := capnweb.DefaultRegistry.ValidateCall("{{$.Name}}", "{{.Name}}", args); err != nil {
		{{if .HasError}}return nil, fmt.Errorf("validation failed: %w", err){{else}}return fmt.Errorf("validation failed: %w", err){{end}}
	}
{{end}}
	// Make RPC call
	promise, err := s.stub.Call(ctx, "{{.Name}}"{{if .InputTypes}}, {{formatArgs .}}{{end}})
	if err != nil {
		{{if .HasError}}return nil, err{{else}}return err{{end}}
	}

{{if hasReturn .}}{{if .IsAsync}}	// Return typed promise
	typedPromise := capnweb.NewTypedPromise[{{returnType .}}](promise)
	return typedPromise, nil{{else}}	// Await result for synchronous call
	result, err := promise.Await(ctx)
	if err != nil {
		{{if .HasError}}return {{returnType . | printf "(%s)(nil), err"}}{{else}}return err{{end}}
	}

	typedResult, ok := result.({{returnType .}})
	if !ok {
		{{if .HasError}}return {{returnType . | printf "(%s)(nil), fmt.Errorf(\"type assertion failed: expected %T, got %T\", typedResult, result)"}}{{else}}return fmt.Errorf("type assertion failed: expected %T, got %T", typedResult, result){{end}}
	}

	{{if .HasError}}return typedResult, nil{{else}}return typedResult{{end}}{{end}}{{else}}{{if .IsAsync}}	return promise, nil{{else}}	_, err = promise.Await(ctx)
	return err{{end}}{{end}}
}
{{end}}

{{if $.WithComments}}// Dispose releases the RPC stub and its resources
{{end}}func (s *{{.Name}}Stub) Dispose() error {
	return s.stub.Dispose()
}

{{if $.WithComments}}// ServiceName returns the name of the RPC service
{{end}}func (s *{{.Name}}Stub) ServiceName() string {
	return "{{.ServiceName}}"
}

{{end}}`
}

// formatType formats a reflect.Type for code generation
func (g *CodeGenerator) formatType(t reflect.Type) string {
	if t == nil {
		return "interface{}"
	}

	switch t.Kind() {
	case reflect.Ptr:
		return "*" + g.formatType(t.Elem())
	case reflect.Slice:
		return "[]" + g.formatType(t.Elem())
	case reflect.Array:
		return fmt.Sprintf("[%d]%s", t.Len(), g.formatType(t.Elem()))
	case reflect.Map:
		return fmt.Sprintf("map[%s]%s", g.formatType(t.Key()), g.formatType(t.Elem()))
	case reflect.Chan:
		return "chan " + g.formatType(t.Elem())
	case reflect.Func:
		return t.String() // Use full function signature
	default:
		// Handle named types
		if t.PkgPath() != "" && t.PkgPath() != g.options.PackageName {
			// Qualify with package name
			parts := strings.Split(t.PkgPath(), "/")
			pkg := parts[len(parts)-1]
			return pkg + "." + t.Name()
		}
		return t.String()
	}
}

// formatPromiseType formats the return type for a method
func (g *CodeGenerator) formatPromiseType(method *RpcMethod) string {
	if method.OutputType != nil {
		if method.IsAsync {
			if g.options.UseGenerics {
				returnType := g.formatType(method.OutputType)
				if method.HasError {
					return fmt.Sprintf("(*capnweb.TypedPromise[%s], error)", returnType)
				}
				return fmt.Sprintf("*capnweb.TypedPromise[%s]", returnType)
			} else {
				if method.HasError {
					return "(*capnweb.Promise, error)"
				}
				return "*capnweb.Promise"
			}
		} else {
			returnType := g.formatType(method.OutputType)
			if method.HasError {
				return fmt.Sprintf("(%s, error)", returnType)
			}
			return returnType
		}
	} else {
		if method.IsAsync {
			if method.HasError {
				return "(*capnweb.Promise, error)"
			}
			return "*capnweb.Promise"
		} else {
			return "error"
		}
	}
}

// formatParameters formats method parameters for code generation
func (g *CodeGenerator) formatParameters(method *RpcMethod) string {
	params := []string{"ctx context.Context"}

	for i, paramType := range method.InputTypes {
		params = append(params, fmt.Sprintf("arg%d %s", i, g.formatType(paramType)))
	}

	return strings.Join(params, ", ")
}

// formatArguments formats method arguments for RPC calls
func (g *CodeGenerator) formatArguments(method *RpcMethod) string {
	if len(method.InputTypes) == 0 {
		return ""
	}

	args := make([]string, len(method.InputTypes))
	for i := range method.InputTypes {
		args[i] = fmt.Sprintf("arg%d", i)
	}

	return strings.Join(args, ", ")
}

// ParseInterfaces parses Go source code to extract interface definitions
func (g *CodeGenerator) ParseInterfaces(source string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "", source, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse source: %w", err)
	}

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			if iface, ok := x.Type.(*ast.InterfaceType); ok {
				if err := g.parseInterfaceFromAST(x.Name.Name, iface); err != nil {
					fmt.Printf("Warning: failed to parse interface %s: %v\n", x.Name.Name, err)
				}
			}
		}
		return true
	})

	return nil
}

// parseInterfaceFromAST parses an interface from AST
func (g *CodeGenerator) parseInterfaceFromAST(name string, iface *ast.InterfaceType) error {
	// This is a simplified implementation
	// In a full implementation, we would extract method signatures from the AST
	// and register them with the interface registry
	fmt.Printf("Found interface: %s with %d methods\n", name, len(iface.Methods.List))
	return nil
}

// FormatCode formats generated Go code
func (g *CodeGenerator) FormatCode(source []byte) ([]byte, error) {
	return format.Source(source)
}

// CLI interface for code generation

// GenerateStubsFromFile generates stubs from interfaces in a Go file
func GenerateStubsFromFile(inputFile, outputFile string, options CodeGenOptions) error {
	generator := NewCodeGenerator(DefaultRegistry, options)

	// Parse input file
	source := fmt.Sprintf(`
		package %s

		// Placeholder for parsed interfaces
		// In a real implementation, we would read and parse the input file
	`, options.PackageName)

	if err := generator.ParseInterfaces(source); err != nil {
		return fmt.Errorf("failed to parse interfaces: %w", err)
	}

	// Generate output
	var output strings.Builder
	if err := generator.GenerateCode(&output); err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	// Format the code
	formatted, err := generator.FormatCode([]byte(output.String()))
	if err != nil {
		return fmt.Errorf("failed to format code: %w", err)
	}

	// In a real implementation, we would write to the output file
	fmt.Printf("Generated code would be written to: %s\n", outputFile)
	fmt.Printf("Generated code:\n%s\n", string(formatted))

	return nil
}

// Example usage function
func ExampleCodeGeneration() {
	// Register an example interface
	// Placeholder types for the example
	type ExampleUser struct {
		ID   int    `json:"id"`
		Name string `json:"name"`
	}

	type ExampleProfile struct {
		UserID int    `json:"userId"`
		Bio    string `json:"bio"`
	}

	type UserAPI interface {
		Authenticate(ctx context.Context, token string) (*ExampleUser, error)
		GetProfile(ctx context.Context, userID int) (*ExampleProfile, error)
		UpdateProfile(ctx context.Context, userID int, profile *ExampleProfile) error
	}

	// Register the interface
	registry := NewInterfaceRegistry()
	_, err := registry.RegisterInterface((*UserAPI)(nil))
	if err != nil {
		fmt.Printf("Failed to register interface: %v\n", err)
		return
	}

	// Generate code
	options := DefaultCodeGenOptions()
	options.PackageName = "example"

	generator := NewCodeGenerator(registry, options)
	var output strings.Builder
	if err := generator.GenerateCode(&output); err != nil {
		fmt.Printf("Failed to generate code: %v\n", err)
		return
	}

	fmt.Println("Generated stub code:")
	fmt.Println(output.String())
}